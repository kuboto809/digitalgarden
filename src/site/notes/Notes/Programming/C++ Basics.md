---
{"dg-publish":true,"permalink":"/Notes/Programming/C++ Basics/","noteIcon":""}
---

# Chapter 0
## Why C++ -- The advantages!
- Cuz we want to access hardware. 
- We write codes, then they get compiled into machines codes which our platform understands and runs.
- By writing C++, we have access to everything we want the machine to do.
- We need different compilers for different platform. E.g. x86 compiler for an x86 CPU. 
- So C++ has a wide platform support. As long as we have a corresponding compiler for our platform, we can get our code runs on it.
- Java/C# first runs the written code on a virtual machine, then it gets compiled into machine code. What a INDIRECT way!
## Setup C++ on Windows
- We need at least a compiler to compile our codes to machine codes. U can write ur code in notepad but we better have a IDE (Integrated Development environment ) to debug.
- Try Visual assist for Visual studio
- Choose Desktop dev with C++ in VS. Universal Windows dev is for UWP dev which we don't need yet.
- If you didn't do it when installing it, open VS and choose go without code. Then Tools > Get tools and features, then install Desktop dev with.
### VS settings (Haven't completed; Visual assist needed)
 ![youtube](https://youtu.be/1OsGXuNA5cc?t=251)
 
## Open a new file
 File > New project > Visual C++ > General > Empty Project
 - Make sure ur path has no space in it
 ###  Then make a new  cpp file
Right click source file, click add, select cpp from the templates. 
## Run a program
- Right click on ur project and click build
- Then u can see that it built a .exe file in a certain path shown in the consol.
- U can go to that path and open the .exe to run ur program
- Or u can click Local Windows debug to run it
## How C++ works
### The structure of the program
#### The "#"
This is followed by a "pre-processed statement". That means the machine does whatever it is told to do before everything u write.
#### The "include"
It copies the header files (in this case we need a header file called cout) and pastes it into the current file. The header files do not get compiled -- they gets included into the cpp files.
#### The "int main () function"
It is an entry point of the program, which means machine executes the code starts from here.
- The "int" in front of main does not mean that the main function returns a integer. The main function doesn't have to return anyting. It assumes u return 0.
#### The "<<"
These operators are functions.
They can be thought of as " cout. print ("") ".

## Compiling
Each cpp file get compiled into a object file. In VS it is called .obj. Linker takes them together to make a .exe.
In VS, hit ctrl + F7 to compile a single cpp file. Or add a compile button like the following.
![Pasted image 20231103145626.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231103145626.png)

This is the object file that the compiler has generated.
![Pasted image 20231103150045.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231103150045.png)
### Preprocessing
To see how the preprocessing file looks like, in VS we need to right click our project, click properties, go to C/C++，preprocessing. 
![Pasted image 20231103162618.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231103162618.png)
Note that it won't generate .obj anymore. So if we don't care about preprocessing files, make sure to change it back.
Since .obj is binary codes which are not readable, we want to output .asm codes which are more readable. Select "output" instead of "preprocessing" in the manual, and set ASM output to OnlyList.
#### The "#include"
It tells the preprocessor to open the specified file, read what's in it, and paste everything to the file where you wrote ur include statement.
For example, we right click header file, make a new header file called "EndBrace.h". In this header file, we only write a "}".
In our main code, we delete one of the "}" and replace it by
```
#include "Endbrace.h"
```
**Note that we use "" instead of "<>"**
#### The "#define"
```
#define "what you want to replace" "replacement"
```
For example, we write 
```
#define INTEGER int
```
Then we can write
```
INTEGER main()
{
	INTERGER m = 0;
}
```
And if we open the .i file generated by the preprocessor, we can see that nothing changed in it. Cuz we have told the preprocessor to translate the word "INTERGER" to "int". If we change "int" into apple, then in the .i file it will look like this:
```
apple main()
{
	apple m = 0;
}
```
The texts in `""` won't get replaced.
The pre-defined macro `__DATE__` and `__TIME__` gives u the current date and time.
#### The "#if "
It includes codes based on the given condition.
For example if we write
```
#if 1
xxx
your code 
xxx
#endif
```
Since if 1 means true, it will process ur code like normal. But if we change it to "if 0", we will see there's nothing in the .i file.
## Put a part of the program into a new file
Right click on the source file, click add, select cpp file, then write what u want. Let's say u moved a function, say, Log (), in main () into this new cpp file, which we now called "sub".
### Declaration of a function
But the main function has no idea what the Log function is, so there goes the error message. What we now need to do is declare the log function in main so that main knows it exists. Main doesn't care if it actually exists. If we tell it that it exists, it is gonna believe us. This is called declaration.
To do a declaration in main (), we need to write
```
void Log(const char* msg);
```
Here we have the type of output variable and the function's name and its type of input variable (the name of the input variable "msg" can also be ommited).
### Definition of a function
Definition of a function is what the function actually is. Here the definition of the log function is done in "sub" file. We need to write out the body of the function here.
### Linker's job
When we compile the whole project, linker finds where the Log function declared in main () is actually at. That is, its job is to wire up functions. Linker takes the definiton of the log () function in sub. obj and takes it into a common binary, which is our project .exe.
## Header files
It is a place where we can put all of our declaration of functions in so that we don't have to declare the functions used in every cpp files.
When we have a function, say Multiply, defined somewhere, let's call it A.cpp, and we want to call Multiply in a B.cpp file, we need to declare it at the beginning like so:
```
int Multiply(int a, int b);
```
And if we want to use Multiply in C.cpp as well, we have to write that again.
But if we create a header file (lets call it mul. h) containing the above line, we only need to write
```
#include "mul.h"
```
in the cpp files where the function is used.
If we have multiple functions to declare, we can store all of the declarations in one header file and include the header file in every cpp file.
Note that what "include" does is copy and paste, so we get an error if a declaration of, say, a struct, is run twice, cuz that means we declare two structs with the same name.
So we want to add
```
#pragma once
```
at the very beginning of the header file. That means if something in the header file is already declared, it won't be declared again in a single translation unit.
Or u can write
```
#ifndef Mul
#define Mul
[the codes in header file]
#endif
```
That means u call all ur codes in a header file Mul. Then it checks if Mul has already defined, which means it is already included. 
### The difference between "" and <>
If the header file is related to the current file in terms of path, we use quotes. E.g. 
```
#include "../header.h"
```
Where "../" means to go back to the upper branch of the current file path.
On the other hand, angular brackets are used for including files whose directory is relaterd to the compiler's include directory.
If we change `<iostream>` to `"iostream"`, that's gonna work.
## Linking
When it cannot find where the function is at, we get a linker error. 
A linking error starts with "LNK" and followed by a bunch of numbers, while a compile erorr starts with C and followed by numbers.
For example, if we declare a function in main but we do not write out its body in the whole project.
Another example is that we do not write our main function, then we get an "no entry point" linking error.
Note that it is OK if u compile with no entry point. The compiler doesn't care if it has no entry point.
Note that the linker finds a which fits all 3 condition a function has to fit. So if one condition is unsatisfied, there goes the error.
But there will be a **compile error** if u **do not declare a function** when u compile cuz it doesn't know what the function's name mean. Say if u forget to do declaration in ur main file. If you **declared a function** but linker **cannot find its body**, u get a **linking error**. 
But if you never call the function, u don't get a linking error. 
If u call a function in a function, but u **never call the outer function**, u still **get a linking error**, because the linker thinks that even if u don't call the outer function here, it may be called somewhere else, so u still get an error. If u add "**static**" to the outer function, saying that this function will only be used in this translation unit (this cpp file), then u won't get any errors.
### Two identical functions
If there are two identical functions in one cpp file, when u compile it, there will be a compile error, saying that the function already has a body.
If the two identical functions lies in two different files, when we compile one of the file, we get no error. But when we build our project, we get a linking error, because the linker doesn't know where the function should be linked to.
If u write a function in a header file, and include this header file in two cpp files, say, A and B, u get a linking error. Cuz bascially what u r doing is writing the function in both A and B (cuz "include" means copying it to the current file), which is the same case as the above.
To fix this, u can add "static" or "inline" in front of the function in the header file, or u can write it in only one cpp file and not make it a header file.
## Debugging in VS
Make sure u r in debug mode, otherwise ur codes may look different.
### Breakpoint
A breakpoint is where the program pauses when it arrives the line the breakpoint is set.
Make sure u set a breakpoint on a line which will be executed. A breakpoint set on a blank line will not work.
The Yellow arrow means it is about to execute that line.
If there is a function in the line, u can choose to
a) step in: to jump into the function and check out its body; 
b) step over: to jump to the next line and not go into the function;
c) step out: to jump out of the current function.
If we decided to jump into a function, we can read what the values of the function's input parameters are by hovering our mouse on them.
If u want to exit a loop but not the whole function, just set a breakpoint at which the loop ends and the next line the program is going to execute.
When the program arrives to the ending curly bracket of a for loop, it compares whether it should jump into the loop again. So if we execute this line, the yellow arrow will hop to the for loop beginning, waiting to do i++, if the condition of loop is met. If we now run one more step, the program does i++ and jumps to the first line in the loop body.
### Memory view
Go to Debug > Windows > Memory > Memory 1 to open a memory window. Here we can enter the memory address and see what's in it.
Every two digits in the memory view equals 1 btye
To get the memory address of a variable, write "&" in front of it.
Hover the mouse cursor onto the variable's name to see its value.
In the watch window we can add the variables we want to monitor.
# Chapter 1
## Base 10 and Base 2 numbers
The word "base" means the base number. We write out a few digits to represent a number. If it is in base10 system, the digits we can write out are from 0~9, 10 digits in total; for base2 number system, we can write out 0 and 1 only, which are only 2 digits in total. To derive the value of the number via the numbers we write out, we multiply each of the digit to the increasing power of the base number, and finally add them up.
E.g.  In base 10 system, $586 = 5*10^2 + 8*10^1+6*10^0$ . Here we can see the base number is 10, and the power increases from 0. In base 2 system, $15 = 2^3 + 2^2+ 2^1 + 2^0$. Here we use 2 as the base number, and the power increases from 0 as well.
A bit is a "digit container" which can contain only 0 or 1. If we have 4 bits, we can represent numbers from 0 to 15, because  $15 = 2^3 + 2^2+ 2^1 + 2^0$, which is the maximum number we can get by manipulating the numbers in each bit.
### Representing negative numbers
#### 1. Signed Magnitude Method
If we want to represent negative numbers as well, we need to allocate a bit for representing the "plus or minus" sign (usually the leading bit, i.e. the first bit counting from the left, usually  called the MSB bit -- the most significant bit). E.g. we can represent numbers from -8 ~ 7 if we have 4 bits. Because one bit is for representing the sign, there are only 3 bits left. So for positive numbers, we can have 0 ~ 7 (cuz 3 bits can represent 0 ~ 7 obviously); for negative numbers, we can have -1 ~ -8 (? Not -7 ? ). Here the representation of 0 is ambiguous.
#### 2. 1's Complement Method
Still, we allocate a bit for representing the sign . If it is positive number, everything remains unchanged. The leading bit is 0. If it is a negative number, we write 1 in the leading bit, then switch zero and one in the rest of the bits.
![Pasted image 20231114104448.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114104448.png)
It still has the problem of ambiguous zero.
#### 3. 2's Complement Method
It is the most common method, and it also solves the ambiguous zero problem.
How it is done:
1. write out the number in usual binary representation, leave a leading bit for sign representation.
2. Invert every bit except the leading bit (i.e. 1 becomes 0, 0 becomes 1). 
	- What does inverting bit mean, fundamentally? **Ans**: if we ignore the leading bit. The number $a$, after inverting all its digits, equals $2^n -a$, i.e. the distance between the current number and the border $2^n$.
	- After inverting, the leading bit get inverted as well. That means we get $-2^n$, then we add it with the 
1. Add 1 to the inverted number.
Then we are done. Note that the leading digit means multiplying a -1 to the $2^x$, e.g. if we have four bits, and the leading bit is a -1, then that bit means $-1*2^3 = -8$.
We can see the +0's and -0's representation are the same.
The range we can represent using n bits is $-2^{n}$ ~ $2^{n} -1$
## Variables
We can use **sizeof ()** function to check out the memory size of a type of variable. For example: sizeof (a) where a is an int. 
- Putting a 0 in front of a number means treating it as octal number. E.g. 053 means $5*8^1 + 3*8^0 =53$
- `0x` or `0X` means treating it as a hexadecimal number
### Int
Int normally has 4 bytes, which means 32 bits. There is one bit for storing the sign, so we are left with 31 bits. So the number int can store is $-2, 147, 483, 648$ to $2, 147, 483, 148$.
If we don't want negative numbers, we can use **unsigned int**, which stores numbers from 0 to 2<sup>32</sup>-1 (cuz we have $2^{32}$ bits and we have a zero to store, so one bit is occupied by zero).
### Char
#### Skin Deep Explanation
Char is normally 1 byte. Actually we only need 1 bit to store a character (<span style="background:rgba(240, 107, 5, 0.2)">is it true?</span>), but since computer interacts with bytes but not bits, we still need to make it into a byte.
We can store a character in int -- it just means the number corresponding to that character. E.g.
```
int a = 'a';
cout << a;
```
Then we get 97, which is the ASCII number of the character 'a'.

#### More info
The way computer stores character is converting it to binary numbers and then maps the number to a specific character. The ASCII Table tells the computer which maps to which. The numbers 0 ~ 127 each corresponds to a character, e.g.  $65\mapsto A$. There are 128 characters in total (including uppercase and lowercase letters, and other special characters like spacebar and null), so if we want to represent those characters, we need a container that can store 128 numbers, i.e., we need 8 bits, which is a byte.
To make a char variable: `char a = 'N';` 
We can put in numbers in char, as long as it is not too large. If we want to print it out, we can use prinf ().
`printf("%c", a)` prints out the character N on the screen. Here %c is a placeholder, c means character.
`printf("%d", a)`: %d means we are printing out a decimal number. But how can `'N'` be a decimal number? In this case it refers to the number  that corresponds to N in ASCII Table.
Storing integer in char: `char a = 65;` (Note that `char a = '65'; ` doesn't mean the same thing)
If we print it out as decimal number (use %d), we get 65; if we print it out as char (use %c), we get 'A', which is the character corresponds to 65.
Note that if we store a number in `int` and print it out as character (%c), we can get the character as well.
Conclusion: the type matters not; int and char are only differ in size: `int` is 4 bytes, `char` is 1 byte. Since characters and integers are all just binary numbers, both `int` and `char` can store them. When printing out, they are the same. The difference is how u call the printf () function (%d or %c) when printing character and number.
How negative numbers are stored in char:
![Pasted image 20231114150455.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114150455.png)
The negative numbers can have the same representation as some positive numbers, i.e. if we store a negative number and print it out as a char, that is the same as storing its corresponding positive number.
### Float and double
It is for us to store decimals.
Float is normally 4 bytes and double is 8 bytes. Float, double and long double is different in terms of size and precision. That means, if u store value which exceeds its precision, after some digit it will go random.
When we open up a new float variable, it is actually a "double" type. If we want an actual float, we put "f" at the end of the value. E.g.
```
float a = 3.14f;
```

![Pasted image 20231114151510.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114151510.png)
We can see that the floating point representation can represent a huge range of numbers given the same places (in the case in the picture, there are 4 places, not 4 bits) compared to fixed point representation.
##### Printing them out:
`printf("%f", a);` if u want to specify how many digit u want to print out after the decimal point, e.g. 3 digits, then `printf("%.3f", a)`. `%lf` for printing long double.
##### Arithmetic
If u do arithmetic between two integers and then store it in float, it will be an integer, not a float. E.g. `float a = 4/9 ;`, if u print it out u will get 0, cuz the digit after the decimal point are truncated.
If u want those digits, do arithmetic between floats or doubles, `float a = 4.0/9.0 ;`. Note that by default the '4.0' and '9.0' are double as mentioned above.
### Bool
Bool is 1 byte. It can be true of false, corresponding to 1 and 0.
If it takes in any other number except 0, it will see it as true.
We can initiate a bool like this: `bool result = x == 5;`
This means `result` will be 1, if x is equal to 5; if not, 0.
## Exceeding the range
### The unsigned case
If we have only an unsigned interger which is only 3 bits, and we try to store a number which is greater than 7, then the result we get is the same as if we are doing a mod 8 operation to that number. E.g. storing 8 will get us 0.
In general, $n$ bits means mod $2^n$, when exceeded (unsigned).
![Exceeding The Valid Range of Data Types 4-12 screenshot.png](/img/user/Notes/Programming/attachments/Exceeding%20The%20Valid%20Range%20of%20Data%20Types%204-12%20screenshot.png)
### The signed case
![Pasted image 20231114114129.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114114129.png)
Its logic is still the same as doing mod operation.
From the above picture, we know that
$2147483647+ 1 \mapsto-2147483648$
$-2147483648 -1 \mapsto 2147483647$
## Printing the variables
Use `printf()` function
`printf("the text and placeholder", variable1, variable2, ...)`
'%' is a modifier: 
`%d`: decimal numbers
`%s`: string
`%c`: char
`%x`: hexadecimal numbers (lowercase letters, if u want uppercase letters, do `%X` instead)
	`printf()` not only prints the content on the screen, it also **returns** the number of characters it successfully printed.
`printf("%10s", "Hello")`: the 10 here means print the string up to 10 characters wide. But here we have only 5 characters, so it adds 5 spaces in frocch looks like this `     Hello`. If our characters are longer than we specified, it prints them out normally.
For other integers:
![Pasted image 20231114101453.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114101453.png)
Pattern: replace 'd' with 'u' if you want to print an unsigned integer. Put an 'l' in front of it if it is a "long" interger. If it is even longer, put one more 'l' in front of it.
<font color="#d99694">Does printing an integer as unsigned mean counting its MSB as a part of the positive numbere binary representation?</font>
### The puts () function
- is a function declared in <stdio.h> library (these all are as well)
- Is used to write strings to the output screen
- Automatically writes a newline character after writing the string to the output screen
Syntax: `puts(s);` where `s` is the pointer to the string literal;
### putchar () function

![Pasted image 20231119164925.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119164925.png)
## Reading inputs
### scanf () function
We can use `scanf()` to read inputs from standard input -- our keyboard!
Scanf means Scan Formatted string.
It also uses format modifiers.
Syntax: `scanf("formatModifier", &var_name);`
E.g. `scanf("%d", &count);`
The "&" is called "address-of" operator. It gets the memory address of a variable.
Scanf () needs to store the data read in a variable, so we need to tell it the address of the variable.
Since `char a[N]="Hello"` is an array, which is treated as a pointer to the base address, we can write `scanf("%s", a);` to store the string we read inside a string variable (a char string). There is no need to put `&`.
Scanf () doesn't store the white space characters in the string variable.
It only reads characters other than white spaces and store them in the specified character array until it encounters a white-space character.
### gets () function
It reads the whole line of input.
Syntax: `gets(a);`, where a is a char array.
- Both, gets () and scanf () functions have no way to detect when the character array is full.
Both of them never checks the maximum limit of inout characters. Henc ethey may cause undefined behaviour and probably lead to **buffer overflow** error which eventually causes the program to crash.
For scanf (), by using `%ns`, where n indicates the number of characters allowed to store in the character array, we can prevent it.
For gets (), it is unsafe. It is better to use the `fgets()`, where u can assign the maximum character it takes in.
### getchar () function
It reads in one character.
## Functions
If we don't want duplicate codes, we can make a function so that whenever we want to do the same operation again and again, we don't have to copy and paste our codes.
Note that if we do copy and paste our code, we might forget to change some details, which can lead to error. For example, we want to do an operation and output the result called result1, then the second operation and result2, that means we need to make 2 variables to store the results and then output them. But we may forget to create a new variable when we copy the lines.
Why we need functions:
1.  Reusability 
	Once the function is defined, it can be reused over and over again.
2. Abstracton
	If you are just using the function in your program then you don't have to worry about how it works inside!
We don't want to create a function for everything cuz when it operates, it takes up memory space and the data jumps back and forth in memory, which takes time.
Here is how a function look like:
**Function Definition**
```
[The output type of variable] [Function name]([Input parameters])
{
	[What the function does]
}
```
And here is how we **declare** a function:
**Function Declaration**
![Pasted image 20231116155651.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116155651.png)
- It is not necessary to put the name of the parameters in function prototype
#### Taking in an array as an argument
We need to state the type of the array in definition, like this:
```
int func(int a, int b[])
{
bla
}

int main()
{
	int b[10] = { bla };
	func(1, b);
}
```
#### **Notes**
- if we modify the array in func (), the changes will be stored. Because when we pass an array into the function, we are actually passing its address, so we are manipulating the array directly instead of creating a parameter and doing copy and paste. This is also how we can return multiple values from a function -- we can store our data in an array, then access the array outside the function.
- the `b` in `func(1,b);` means the base address of the array b, that means we are passing an address to func (). We can also write `int func(int a, int *b)` in the function definition.
![Pasted image 20231119125429.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119125429.png)
- when you define a function parameter as an array, like `int b[]`, it is treated as a pointer to the first element of the array. So, `int b[]` and `int *b` in the function definition are interchangeable.
- But we cannot perform the operation `b++` in the function `add()`. In the add function, if the parameter `b` is declared as `int b[]`, you cannot perform pointer arithmetic operations like `b++` directly on the array parameter itself.
- If you need to perform pointer arithmetic or modify the pointer itself within the function, you should declare the parameter as `int *b` instead. This allows you to manipulate the pointer `b` using operations like `b++`, `b+1`, etc., which would not be possible if `b` is declared as `int b[]`.
#### Taking in a pointer as argument
```
int func(int *ptr)
{
*ptr = 2;
}

int main()
{
	int b;
	int b[10] = { bla };
	func(1, &b);
}
```
Here we pass the address of b into func (), then we dereference it and assign the value 2 to b.
Note that we need to write `int *ptr` in the definition. Make sure not to forget writing the `*`, otherwise `ptr` will be treated as `int`. Here `int *ptr` means we **initialize** `ptr` as a pointer and points to the direction we pass (because we pass an address to it, that is, `int *ptr = &b` -- an initialization). 
#### Returning an address
Then the return type of our function will be `int *` or other type with a star. For example
```
int *func(int n)
{
bla
return &n;
}
```
Here we **return the address** of a. We can store the return value into a pointer like this:
`int *ptr = func(a);`
*Debugging*
	- If we call a function before declaring it (the function's definition is at the bottom), the compiler assumes that the function returns integer. If our function doesn't return integer, there will be a "conflicting type" error. Because when it reaches the bottom and sees our definition, the return type doesn't match.
	 -If we write return in the function body but do not specify the type of the return variable in the head of the function, we get an error.
	- DON'T return the address of a local variable. Because the local variable gets destroyed after the completion of the function. So the address is now meaningless.
If we want a function to take in two variables and return their product, we write
```
int Multiply(int a, int b)
{
	int result = a*b;
	return result;
}
```
Explain: "Multiply" is the name we give to our function. it takes in two variabes, and multiply them and store the result in a variable called result. Then it return the product of them. So we can use a variable to store the returned value like this:
```
c = Multiply(2,4);
```
That means we put in 2, 4 as a and b respectively. Then these two numbers get multiplied, which is 8. The answer 8 is stored in a local variable result in the function (which means that we cannot use the variable "result" outside the function). Then "result" is returned and stored in c. So we get c = 8;
#### The Difference between **Parameter** and **Argument**
Parameter: is a variable in the declaration and definition of the function.
Argument: is the actual value of the parameter that gets passed to the function.
NOTE: Parameter is also called as Formal Parameter and Argument is also called as Actual Parameter.
#### Call by Reference
![Pasted image 20231116162807.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116162807.png)
	We pass the address of variables into the function. Then we find where the variables are at and manipulate them directly.
## The scope of variable
### Definition
- The area under which a variable is applicable or alive
Strict Definition: a block or a region where a variable is declared. defined and used and when a block or aregion ends, variable is automatically <u>destroyed</u>.
![Pasted image 20231114160953.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114160953.png)
![Pasted image 20231114161229.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114161229.png)
	Note that only redefinition within the same block will cause error. Also, the compiler prefer to choose the variable that is local to the function calling it. If there is no local variable in the function, it tries to grab one that is closest to it.
### Global Variable
- it is visible to ALL functions in ALL files. Though if u want to use it u need to write `extern` to tell the compiler to grab it. 
- It is initialized to 0 by default
![Pasted image 20231114161548.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114161548.png)
- Define a variable outside any block/function makes it a global variable.
## Variable Modifier
### Auto modifier
![Pasted image 20231114162028.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114162028.png)
By default the variables u declare are auto.
It will be destroyed once the function ends.
If you won't initialize auto variable, by default it will beinitialized with some garbage (random) value.
On the other hand, global variable by default initialized to 0.
### External Modifier
![Pasted image 20231114162405.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114162405.png)
Declaration: tell the compiler what type of variable it is.
<mark style="background: #593D4FB5;">Definition: tell the compiler to allocate some memory for it (it doesn't mean assigning a value to it).</mark>
`extern`: we tell the compiler to find the variable outside of the current scope.
If we don't want the compiler to allocate memory for it, we then make our variable external variable. Consider the case that we have defined the variable in some other files, and we want to reuse it. In this case we tell our compiler not to allocate memory for it again. We can write `extern int a;` before main (). Then if we call our variable a inside main (), the linker will try to grab the variable a in some other files, if we have defined it in somewhere else.
If we write `extern int a;` in main (), that means we tell the compiler to find the variable a outside main (). It may be defined as a global variable or so.
### Register Modifier
Syntax: `register var_type var_name;` e.g. `register int a;`
 It hints the compiler to store a variable in register memory. This is done because access time reduces greatly for most freguently referred variables. This is the choice of compiler whether it puts the given variable in register or not (so the variable doesn't necessarily get stored in register). Usually compiler themselves do the necessary optimizations.
### Static Modifier
- It makes the variable only visible in the current file. Other files cannot see it. 
- It also initializes the variable to 0. If we want to initialize it to some other value, it must be a constant. 
- We cannot assign a variable to a static variable, i.e., `static int a = b;` is not allowed since b is a variable.
- A static variable preserves its previous value in its previous scope and **<mark style="background: #593D4FB5;">is not initialized again</mark>** in the new scope
![Pasted image 20231114174101.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114174101.png)
If a static variable is initialized (with a value differs to 0), it is stored in the initialized section; otherwise, the uninitialized section (even though its value is 0).
Syntax: `static var_type var_name;`
>[!Tips]- An Example of the usage of Static Variable
> ```
> int fun ()
> {
> 	static int count  = 0;
> 	count++ ;
> 	return count;
> }
> int main ()
> {
> 	printf ("%d", fun ());
> 	printf ("%d", fun ());
> }
> ```
> The above program prints `1 2`. Note that count won't be initialized to 0 every time fun () is called. Static variables are only initialized once and live till the end of the program

It can also be used to make a function only visible in its definition file, not all files (A function by default is a global function).
Syntax: `static definition_of_a_function`. So that this function is only accessible in current file.
**Local permanence**
If we declare a static variable in a function, it won't get destroyed after the function ends. Also, other functions in the same file cannot see it.
## Using constants
- We can define a constant using `#define`. E.g. `#define PI = 3.14159` Note that we do not add `;` at the end
- We better use capital letters so that it won't collide with our variables elsewhere.
Or we can use `const`. 
Syntax: `const var_type var_name;`
Then we won't be able to change its value later in the program. That is, it is a read-only variable.
# Chapter2
## Operators
### Arithmetic operators
`+ - * / %` are arithmetic operators. They are pretty basic so nothing needs to be explained.
### Increment & decrement operators
It increases/decreases the value of a variable by 1.
#### Lvalue and rvalue
Ivalue (left value) 
- object that <mark style="background: #593D4FB5;">has an identifiable location in memory</mark> (i.e. having an address) 
- In any assignment statement "lvalue" must have thecapability to hold the data
- lvalue must be a variable because they have the capability to store the data
- lvalue cannot be a function, expression (like a+b) or a constant (like 3, 4 etc) (because they cannot store the data)
rvalue (right value)
- An object that has no identifiable location in memory
- Anything which is capable of returning a constant/expression or value
- Expressions like a + b will return some constant value.
![Pasted image 20231114184903.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114184903.png)
![Pasted image 20231114185726.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114185726.png)
Post-increment /decrement in context of equation
- **First use** the value in the equation and **then increment** the value (after the expression is completed, i.e this expression has been evaluated)
- Read first, write second
Pre-increment /decrement in context of equation
- **First increment** the value and **then use** in the equation after completion of the equation (after it reads the whole equation, it finally subsitutes in the value)
- Write first, read second
### Lexical Analysis
Lexical analyzer goes to the right as much as it can to find meaningful lexemes. Then lexemes are mapped to tokens.
![Pasted image 20231114190623.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114190623.png)

### Relational operators
`!= == <= >= > <` are relational operators. They return `true` or `false`.
#### Short circuit in logical operators
![Pasted image 20231114192555.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231114192555.png)
In the case of `OR`: if there is a condition anywhere in the expression that returns True, then the rest of theconditions after that will not be evaluated.

### Bitwise operators
`& | ~ << >> ^` are bitwise operators.
Bitewise AND Operator 
![Pasted image 20231116082943.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116082943.png)
Bitwise OR Operator
![Pasted image 20231116083014.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116083014.png)
Bitwise NOT Operator
![Pasted image 20231116083036.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116083036.png)
Left Shift Operator
![Pasted image 20231116092305.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092305.png)
- When bits are shifted left then trailing positions arefilled with zeros.
![Pasted image 20231116092349.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092349.png)
![Pasted image 20231116092428.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092428.png)
Right Shift Operator
![Pasted image 20231116092605.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092605.png)
![Pasted image 20231116092708.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092708.png)
- We truncate the remainder
Bitwise XOR Operator
![Pasted image 20231116092816.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116092816.png)
<font color="#d99694">OR = AND || XOR ?</font>
- Result of XOR is 1 when two bits are different; otherwise the result is 0
>[!NOTE]- Why do I need it?
>Ans: it can be used to swap variables:
>```
>a = 0100 = 4
>b =  0011 = 3
>a = a ^ b =  0111 = 7
>b = a ^ b = 0100 = 4
>a = a ^ b = 0011 = 3
>
Thus we swapped the value of a and b without using the third variable.
>There is also another way to do this:
>```
>```
int a = 3; int b = 4;
a = a+b; //(a = 7, b = 4) 
b = a-b; //(a = 7, b = 3)
a = a-b; //(a = 4, b = 3)
>```

### Assignment operators
= is assignment operator. There are many shorthand assignment operators, like `+= *= <<= &=` etc.
E.g. `a += 1` means` a  = a + 1`
### Conditional operator
It looks like `Expression 1 ? Expression 2 : Expression 3`
Here the expression 1 will be treated as a booleen expression.
![Pasted image 20231116101041.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116101041.png)
The above is equivalent to
```
if (mark > 33)
	result = 'p';
else
	resulf = 'f';
```
- It returns an expression, so<mark style="background: #593D4FB5;"> it is an r-value</mark>
### Comma Operator
![Pasted image 20231116101717.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116101717.png)
It is a separator in 
- Function calls and definitions
- Variable declaration
- Enum declaration
![Pasted image 20231116101839.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116101839.png)
- i.e. evaluates but doesn't return
![Pasted image 20231116102018.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116102018.png)
![Pasted image 20231116102116.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116102116.png)
### Precedence of Operators
- Operators with higher precedence will be evaluated first
- Associativity of operators come into picture when precedence of operators are the same and we need to decide which operator will be evaluated first
Associativity can be either Left to right OR Right to left
![Pasted image 20231116102657.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116102657.png)
Precedence and Associativity Table
![Pasted image 20231116102722.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116102722.png)
![Pasted image 20231116103534.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116103534.png)
**Notes:**
- Precedence of **Postfix** Increment/Decrement operator is **greater** than Prefix Increment/Decrement.
- Associativity of Postfix is also different from Prefix. Associativity of **postfix** operators is from **left to right** and that of **prefix** operators is from **right to left**.
![Pasted image 20231116103829.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116103829.png)
- If we have only one operator, associativity will not work
## Conditions and branches
### If statement
Anything that goes in the structure: "A is dependent to B" can be expressed in if statement
E.g. going to the homepage is dependent to the homepage button clicking
```
if (homepage_button_is_clicked)
	go to homepage
else
	stays at current page
```
![Pasted image 20231116111027.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116111027.png)
The playstore button clicking is dependent to the app button clicking.
- Too many ifs slows down the program
- `if else` is the same as `if { else {} }
- If the body is empty, it won't be considered as an error.
### Switch
Its body gets evaluated from top to bottom.
![Pasted image 20231116111727.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116111727.png)
Puts in a INTEGER to evaluate. 
![Pasted image 20231116111842.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116111842.png)
- DON'T put a float / variable in the case label.
- If there is no break, ALL statements below will get executed (even it doesn't fits the case label)
## Loops
### For loop
```
for([code that runs only once]; [condition]; [code that runs every time after it runs the body])
```
At the very beginning, it runs the initialization step. Then it runs the body, then does the increment, and see if it matches the condition.
![Pasted image 20231116112458.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116112458.png)
We can write it as follows:
```
int i = 0;
for(; i < 5; )
{
	cout << i << endl;
	i++;
}
```
Cuz if we leave them blank, that means nothing runs, but the loop can still go on.
We can even take out the condition part:
```
int i = 0;
for (; condition; )
{
	cout << i << endl;
	i++;
	if (!(i == 5))
		{
			condition = true;
		}
}
```
This presents the logic more clearly: it executes the loop body, does the increment, and check condition.
>[!Tips]- The bounday condition of For loop
>How many times will the For body be executed? And how to know it quickly?
>```
>int i = 1024;
>for (; i ; i >=)
>{
>	printf ("%d", i);
>}
>```
>We can know it quicky by going through the thought process below:
>First, we consider 
>```
>Execute the body
>Does the increment
>```
>As one round
>And then we consider: how many rounds can the variable "survive", i.e. how many times will the increment gets executed and even after that the boolean condition is still true. The number of times that the body will get executed will be our result plus 1.
>In the above example. 1024 can survive 10 rounds. That is, it fits the boolean condition after 10 times of increment (dividing by 2). After 10 rounds, the statement has been printed 10 times, and now `i = 1`. Now this is the last time that `i` fits the condition. So the programs prints out the statement the 11 th time, and then does the increment. After that, i no longer fits the condition. So overall, the the printing has been done 11 times.

### While
- Pretty much the same as for.
- If the body is empty, it won't be considered as an error. It just keeps evaluating the loop condition
### Do ... While
```
do
{

} while([condition]);
```
It does the body at least once no matter what.
![Pasted image 20231116112756.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116112756.png)
## Control flow
### Continue
If it is executed, the program will jump to the next iteration of the for loop, e.g. the head of the for loop and does the increment.
>[!Tip]- A Example Program of Printing Odd Number From 1 ~ 20 Using Continue
>```
>int i = 1, n = 2;
>for (i = 1; i <= 20; i++)
>{
>		if (i == n)
>		{
>			n += 2;
>			continue;
>		}
>		printf ("%d", i);
>}
>```
>Here we use Continue to throw out the unwanted even `i`. We first check if the current i is odd. If not, we prevent it from being printed out. The way we check if it is odd is by using a variable `n`, with n being the next even number. Hence, we want `n` to grow alongside with `i`.
### Break
If it is executed, the program will jump out of the loop.
### Return
It returns a value...
If u write `return 0;` in `main()`, ur program terminates at that line.

## Static and Dynamic Scoping
Scoping helps us reuse variable names. If we don't know the scope of a variable, we might run into trouble when passing or initializing variables between functions.
### Stack and Activision Record
![Pasted image 20231117141813.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117141813.png)
![Pasted image 20231117141829.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117141829.png)
![Pasted image 20231117141857.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117141857.png)
### Static Scoping
In Static scoping (or lexical scoping), definition of a variable is resolved by **searching its containing block** or function. If that fails, **then** searching the **outer containing block** and so on. That is, **向外寻找**。
![Pasted image 20231117143322.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117143322.png)
### Dynamic Scoping
In dynamic scoping, definition of a variable is resolved by searching its containing block and if not found, then searching its calling function, and if still not found then the function which called that calling function will be searched and so on. That is, **向上层寻找**, or looks down the stack.
![Pasted image 20231117145400.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117145400.png)
Modern programming languages follow static scoping. C/C++ also follows static scoping.
## Recursion
- Recursion is a process in which a function calls itself directly or indirectly
### Direct recursion
The function calls itself.
### Indirect recursion
A function (let say fun) is called indirect recursive if it calls another function (let say fun 2) and then fun 2 calls fun directly or indirectly.
![Pasted image 20231117233238.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117233238.png)
### The advantage and disadvantage of recursive program
Every recursive program can be modeled into an iterative program.
Advantage: recursive programs are more elegant and reguires relatively **less lines of code**.
Disadvantage: recursive programs require **more space** than iterative programs (cuz more activision record are stored in the stack).
**Stack overflow**: a stack overflow occurs when the call stack, which is used to manage function calls and local variables, becomes filled with too many function calls that haven't yet completed. 
## Array
An Array is a data structure containing a number of data values (all of whichare of same type).
The length of an array can be specified by any integer constant expression (like `int a[q = 21/7];`).
Specifying the length of an array using macro is considered t be an excellent practice (cuz we can change the value of the length of the array easily later).
Like this:
```
#define N 210
int a[N];
```
### Accessing the elements in an array
![Pasted image 20231118152500.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118152500.png)
### Initializing an arraay
![Pasted image 20231118152833.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118152833.png)
- If we don't specify the length of the array when initializing it, the compiler will set its length to the number of elements in the array when it was being initialized
- If the number of elements are lesser than the length of the array then the rest of the locations are automatically filled by value 0
- An easy way to initialize the whole array with value 0 is `int a[10] = {0};`
- `int a[10] = {};` will lead to error; Also adding too many elements until the array explodes is illegal
### Designated initialization of an array
![Pasted image 20231118153317.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118153317.png)
Note that we use comma to separate the designated numbers.
![Pasted image 20231118153445.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118153445.png)
![Pasted image 20231118160532.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118160532.png)
- Note that we can pass the array into a function by passing the array's name
### Constant array
Add the word `const` in the array definition
- It assures us that the program will not modify the array which may contain some valuable information
- It also helps the compiler to catch errors byinforming that there is no intention to modify thisarray
## Pointers
- Pointer is a special variable that is capable of storing some address
- It points to a memory location where the first byte is stored
Like in the following picture, if the pointer p points to i, it will point to 1002, which is the first byte of i (Assuming i takes 2 bytes).
![Pasted image 20231118165026.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118165026.png)
### Initializing a pointer
Syntax: `data_type *pointer_name;` 
Here data type means the type of the "target".
![Pasted image 20231118165457.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118165457.png)
The above is equivalent to `int x =5, *ptr = &x;` (cuz the `*ptr` also has `int` type.)
`int **prt;` means initializing a pointer which will contain the address of some other pointer.
#### Array of pointer and pointer of array
-  `int *ptr[10];` means making an array full of integer pointers.
-  `int (*ptr)[10];` means a pointer pointing to an array with 10 integers. (`[]` has higher precedence than `*`)
![Pasted image 20231119200946.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119200946.png)
![Pasted image 20231119201031.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119201031.png)
![Pasted image 20231119201043.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119201043.png)
![Pasted image 20231119201119.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119201119.png)
Or
![Pasted image 20231119201334.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119201334.png)

### Dereferencing
That means accessing the value at that memory address.
![Pasted image 20231118165736.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231118165736.png)
### Printing out the address of a variable
`%p` is the format specifier for printing address in printf ().
```
int i = 1;
int *ptr = &i;
printf("%p is the address of i", ptr);

```
### Arithmatic of pointers
#### Addition and Subtraction
Adding an integer to a pointer means moving it forward
![Pasted image 20231119122113.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122113.png)
![Pasted image 20231119122132.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122132.png)
Subtracting an integer to a pointer means moving it backward
![Pasted image 20231119122146.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122146.png)
Doing arithmatic with integer and pointers means operating the address the pointer is pointing to. 1 means 1 byte.
Pointer subtraction: the distance between them
![Pasted image 20231119122208.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122208.png)
Behind the scene:
![Pasted image 20231119122348.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122348.png)
![Pasted image 20231119122703.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122703.png)
We can do increment/decrement to pointers -- it means moving forward/backward for one unit 
We can also compare the pointers -- it means comparing their location in an array.
![Pasted image 20231119122843.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119122843.png)
### Using array's name as a pointer
- The name of an array can be used as a pointer pointing to the first element in the array
![Pasted image 20231119123650.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119123650.png)
Here `a` means the address of the first element in the array `a[]`.
Since `a` is an address, we can add/subtract integers to move our pointer:
![Pasted image 20231119123823.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119123823.png)
Note that we are manipulating the address, so adding/ subtracting integers means moving.
`a[2]` means `*(a+2)` which is equivalent to `2[a]` and `*(2+a)` as well.
#### Printing out a 2 D array using pointers
C++ uses Row Major Order, that is, it stores elements in the rows. If the current row is full, it moves on to the next row and stores elements in it. **(横着排)**
![Pasted image 20231119130321.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119130321.png)
Following the rule of Row Major Order, the pointer first traverse the first row, then it moves on to the next row, printing out the values at the same time.

### Pointing to the whole array
`*` tells the pointer to go inside; `&` tells the pointer to go outside (by inside/ouside we mean the border of our imaginary box.)
`int *ptr = a;` is a pointer pointing to the first element in the array `a[N]`. If we want to point to the whole array, we write `int *ptr[N] = &a` so that it goes outside (from pointing the first element only) and points to the whole array `a[N]`. Its value is the same as `&a[0]`, that is, the address of the first element in the array.
![Pasted image 20231119143530.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119143530.png)
![Pasted image 20231119143812.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119143812.png)
Here `p` points to the whole array, its value is `1000` (cuz it will be the same as the first element inside it). `*p` points to the first element of the array, its value is `1000`. `**p` means getting the value at `1000`, so its value is 1.
### Accessing multi-dimensional array using pointer
![Pasted image 20231119132350.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119132350.png)
In 2D array, `a` doesn't mean the address of an element -- it means the address of an **array** (the first 1D array, the value is the same as its base address). `*a` tells the pointer to go inside, then it enteres the first row, now pointing to the base address of the first 1D array (i.e. pointing to the first element of the first array). To reach the first element in the first row, we need to add one more `*` to tell the pointer to hop in. Finally, `**a` gets us the first element in the first row.
#### Visualization
![Pasted image 20231119132840.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119132840.png)
![Pasted image 20231119132858.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119132858.png)
![Pasted image 20231119133232.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119133232.png)
The case of 3D array is similar
![Pasted image 20231119133332.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119133332.png)
![Pasted image 20231119133740.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119133740.png)
The first star: (enters) which table
The second star: (enters) which row in the table
The third star: (enters) which element in the row
### Pointer pointing to a pointer
![Pasted image 20231119192916.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119192916.png)
![Pasted image 20231119193025.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119193025.png)
`*s1` can get us the value of the char pointer, which is the address of a char.
![Pasted image 20231119193313.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119193313.png)

### Function pointer
- Function pointers are like normal pointers but they have the capability to point to a function




### Debugging
 - Never apply the indirection operator to the uninitialized pointer
- Assigning value to an uninitialized pointer is dangerous (it leads to segmentation error, that is, the program is trying to read/write an illegal memory location.)
Notes: `int *ptr = n;` means initializing the pointer `ptr`, that is, makes it point to the address of n; `*ptr = n;` means assigning the value `n` to where the pointer `ptr` points (if ptr is an initialized pointer, otherwise we get error). `*` doesn't mean dereferencing in initialization; it tells the compiler that `ptr` is a pointer pointing to an integer.
- We cannot assign a new address to `a`, where `a` means the address of the first element in the array
![Pasted image 20231119124021.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119124021.png)

## Strings
- String Literal (or String Constant) is a sequence of characters enclosed within double quotes. E.g. `"Hello!"`
When printing strings, if u want to start a new line **when typing** ur quote (not when printing them out), use `\` to separate them, but it adds four spaces in front of your second quote.
```
printf("You have your own dream \
-- by me");
```
Or u can type another quote with quotes:
```
printf("You have your own dream" 
"-- by me");
```
### How strings are stored
![Pasted image 20231119152614.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119152614.png)
- String literals are stored in read-only memory. So we cannot access the letter `E` and change it to something else.
- `"H"` and `'H'` are not the same. `"H"` is a pointer to the character `H`, while `'H'` is a number (according to the ASCII table)
### How printf () function works
![Pasted image 20231119152644.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119152644.png)
We are actually passing a char pointer to the printf () function. The printf () function starts from the address of the first element in the string (cuz we passed a char pointer to tell it where to start) and traverse the whole string, printing out the letters at the same time, until it reaches `\0`. 
```
const char *a = "Hello";
printf("%s", a);
```
Tells the printf () function to start printing from letter H (cuz `a` points to letter H).
Here the pointer `a` cannot be modified. That means we cannot make `a` points to somewhere else.
- `%.ns` is used to print just a part of the string where `n` is the number of characters to be displayed on the screen.
![Pasted image 20231119160635.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119160635.png)
### Accessing the letters in a string
Let's say `const char *a = "Hello";`, then `a[1]` will be `e`, cuz `a[i]` means a pointer moves from the base address of `a` i units forward. Here `a[i]` means the element at `a+1`, like how we grab an element in an integer array.
### String array
We can create a char array to store the letters.
`char a[] = "Hello";` In this case, there is a 6 bytes long char array storing the letter 'H' 'e' 'l' 'l' 'o', and also the null character `\0`. If we allocate too many memory for a short string, the empty spaces will be filled with '\0'. E.g. `a[10] = "Hello"`. Then there will be 5 `\0` after the letter o.
Since it is an array, we can modify its elements. That means, `a[0] = 'M'` is legal.
`a` is also a pointer here, but now we can modify its value. Like `*a = 'M';`.We can even make `a` point to somewhere else [[pointer pointing to a pointer\|pointer pointing to a pointer]]
### C string Library
The operations for strings are all in `<string.h>` .
#### strcpy ()
![Pasted image 20231119170604.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119170604.png)
![Pasted image 20231119170653.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119170653.png)
- If the length of the string pointed by str1 is greater than the length of thecharacter array str2 then it will be an undefined behaviour (overflow).
To avoid this, we can call `strncpy ()` instead, where we can specify the length of character we want to copy.
![Pasted image 20231119170957.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119170957.png)
However, we need to make sure there is a `\0` at the end of str 2. 
![Pasted image 20231119171127.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119171127.png)
![Pasted image 20231119184505.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119184505.png)
![Pasted image 20231119184845.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119184845.png)
![Pasted image 20231119184951.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119184951.png)
![Pasted image 20231119185054.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119185054.png)
![Pasted image 20231119185424.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119185424.png)
strcmp considers s 1< s2 if either one of the following conditions is satisfied:
- When the first i characters in s 1 and s 2 are same and (i+1) st character of s 1 is less than that of s2
- All characters of s1 match s2, but s1 is shorter than s2
### Array of string
We want to store a set of strings.
![Pasted image 20231119185954.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119185954.png)
This will work, but there are many memory wasted.
![Pasted image 20231119185913.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231119185913.png)
To access the strings in it, use `fruits[i]`. For example, `fruits[1]` refers to the string `"2 Apples"`. 
# Questions done wrong
![Pasted image 20231117093933.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231117093933.png)
No! Static variables are only initialized once.
# Problems Tips
## Arithmetics
What happens when we divide a number by 10?
456/10 -> Remainder = 6 
				Quotient = 45
That is, we can perform the modulus operation to get the last digit, and we can perform division to "cut out" the last digit.
>[!Tips]- How we construct a reverse number
>1. Make a variable to store the result
>2. We get the last digit of the number (by modulus) and STORE IT **in a new variable**
>3. We multiply our result by ten and add the digit we got
>4. Get rid of the last digit (by division)
>5. ![Pasted image 20231116131031.png](/img/user/Notes/Programming/attachments/Pasted%20image%2020231116131031.png)

>[!Tips]- How we get the number of digits of a number
>Lets say q is the number we are curious about. We make a count variable first.
>```
>While (q!= 0)
>{
>	q /= 10;
>	cnt ++;
>}
>```


